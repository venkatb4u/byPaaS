/* gulpfile.js */

// Load some modules which are installed through NPM.
var fs = require('fs');
var del = require('del');
var gulp = require('gulp');
var path = require('path');
var brfs = require('brfs');
var async = require('async');
var rev = require('gulp-rev');
var mkdirp = require('mkdirp');
var sass = require('gulp-sass');
var gulpif = require('gulp-if');
var gzip = require('gulp-gzip');
var watchify = require('watchify');
var lazypipe = require('lazypipe');
var rename = require('gulp-rename');
var nodeSass = require('node-sass');
var concat = require('gulp-concat');
var cssmin = require('gulp-cssmin');
var uglify = require('gulp-uglify');
var notify = require('gulp-notify');
var merge = require('merge-stream');
var filter = require('gulp-filter');
var factor = require('factor-bundle');
var imagemin = require('gulp-imagemin');
var streamify = require('gulp-streamify');
var runSequence = require('run-sequence');
var source = require('vinyl-source-stream');
var awspublish = require('gulp-awspublish');
var parallelize = require('concurrent-transform');

// Setup CLI args
var argv = require('minimist')(process.argv.slice(2));
var env = argv.env || 'local';
var isLocal = (env === 'local');
var root = isLocal ? 'public' : 'build';
var devMode = argv.dev || isLocal;
var debug = argv.debug || isLocal;

// Define some paths
var paths = {
	src: 'assets',
	dest: root,
	dist: 'dist',
	sass: {
		base: 'assets/sass',
		dest: root,
		src: [
			'/*.scss'
		].map(function(path) {
			return 'assets/sass/' + path;
		})
	},
	// This is the final folder that has to be deployed to CDN.
	// All assets are minified, revisioned and compressed here
	cdn: {
		src: 'dist/**/*',
		dest: (env !== 'kc' ? env + '/' : '') + 'assets/'
	},
	// Generated by the file-rev plugin. Since the files name change,
	// we need to replace references to images/fonts when running the
	// node-sass plugin.
	manifest: '.manifest.json',
	init: function() {
		this.targets = 	['public', this.dist, this.dest];
		// The path of an assets will be something like:
		// https://cdn.knowncircle.com/assets/fonts/bootstrap-1c123aca.css
		this.cdn.url = 'https://cdn.knowncircle.com/' + this.cdn.dest;
		this.sass.baseUrl = isLocal ? '' : this.cdn.url;
		return this;
	}
}.init();

function fullpath(file) {
	return paths.src + '/' + file;
}

// Reads a JSON file as an object
function readFile(path) {
	return JSON.parse(fs.readFileSync(path, {encoding: 'utf8'}));
}


// For local environment, the url stays the same. However,
// for CDN, we need to pick up the revisioned equivalent from
// the manifest
function generateSassUrl(url, type, wrap, manifest) {
	url = url.getValue();
	if (isLocal) {
		url = type + '/' + url;
	}
	else {
		var separator, parts;
		// If the font path has # or ? as in:
		// bootstrap/glyphicons-halflings-regular.eot?#iefix
		// bootstrap/glyphicons-halflings-regular.svg#glyphicons_halflingsregular
		// separate and append it at the end to preserve the fixes
		if (url.indexOf('?') !== -1) {
			parts = url.split('?');
			url = parts.shift();
			separator = '?' + parts[0];
		}
		else if (url.indexOf('#') !== -1) {
			parts = url.split('#');
			url = parts.shift();
			separator = '#' + parts[0];
		}
		// Lookup the path in the manifest. By now, its without
		// postfixes - bootstrap/glyphicons-halflings-regular.eot
		url = manifest[type + '/' + url];
		// Restore the postfix, if any
		if (separator) {
			url += separator;
		}
	}
	if (wrap) {
		return new nodeSass.types.String([
			'url("', paths.sass.baseUrl, url, '")'
		].join(''));
	} else {
		return new nodeSass.types.String([
			'"', paths.sass.baseUrl, url, '"'
		].join(''));
	}
}

// SASS
function sassTask(manifest, options) {
	var CssImporter = require('node-sass-css-importer')({
		import_paths: ['assets/bower_components']
	});

	var sassOptions = {
		outputStyle: debug ? 'nested' : 'compressed',
		sourceMap: debug,
		sourceComments: debug,
		includePaths: [
			'assets/bower_components/compass-mixins/lib',
			'assets/bower_components/bootstrap-sass/assets/stylesheets'
		],
		functions: {
			'image-url($url)': function(url) {
				return generateSassUrl(url, 'images', true, manifest);
			},
			'font-url($url)': function(url) {
				return generateSassUrl(url, 'fonts', true, manifest);
			},
			'cdn-url($url, $type)': function(url, type) {
				return generateSassUrl(url, type.getValue(), false, manifest);
			}
		},
		importer: CssImporter
	};

	if (options.development) {
		function run() {
			var start = new Date();
			return gulp.src(paths.sass.src)
				.pipe(sass(sassOptions))
				.pipe(gulp.dest(paths.sass.dest))
				.pipe(notify(function() {
					console.log('SASS built in ' + (Date.now() - start) + 'ms');
				}));
		}
		if (options.watch) {
			gulp.watch(paths.sass.src, run);
		}
		return run();
	}
	else {
		return gulp.src(paths.sass.src)
			.pipe(sass(sassOptions))
			.pipe(revision());
	}
};



//////////////////////////////////////////////////////////
// Task definitions
/////////////////////////////////////////////////////////

gulp.task('clean', function(done) {
	del(paths.targets, done);
});

// Create the destination folder if it doesn't exist
gulp.task('create', function(done) {
	async.each(paths.targets, function(path, next) {
		mkdirp(path, next);
	}, done);
});



gulp.task('filerev', function() {
	return gulp.src(paths.dest + '/**/*').pipe(revision());
});

gulp.task('sass', function() {
	var manifest = isLocal ? null : readFile(paths.manifest);
	return sassTask(manifest, {
		development: devMode
	});
});



gulp.task('watch', function(done) {
	var manifest = isLocal ? null : readFile(paths.manifest);
	// SASS
	sassTask(manifest, {
		development: devMode,
		watch: true
	});
});

gulp.task('deploy', function(done) {
	runSequence('clean', 'create', 'sass', done);
});

gulp.task('default', function(done) {
	runSequence('clean', 'create', ['sass'], done);
});
